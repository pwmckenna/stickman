<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Stickman Fighter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #1a1a2e;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #gameContainer {
            text-align: center;
        }
        canvas {
            border: 3px solid #4a4a6a;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            max-width: 100%;
            height: auto;
        }
        @media (pointer: coarse) {
            body {
                overflow: hidden;
                position: fixed;
                width: 100%;
                height: 100%;
            }
            #gameContainer {
                width: 100%;
                height: 100%;
                display: flex;
                flex-direction: column;
                justify-content: flex-start;
                padding-top: 10px;
            }
            canvas {
                width: 100%;
                max-height: 55vh;
                object-fit: contain;
            }
        }
        #controls {
            color: #888;
            margin-top: 15px;
            font-size: 14px;
        }
        .player-controls {
            display: inline-block;
            margin: 0 30px;
        }
        .player-controls h3 {
            color: #fff;
            margin-bottom: 5px;
        }
        /* Hide keyboard controls on touch devices */
        @media (pointer: coarse) {
            #controls {
                display: none;
            }
        }
        /* Touch controls */
        #touchControls {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 100;
            touch-action: none;
        }
        @media (pointer: coarse) {
            #touchControls {
                display: block;
            }
        }
        .touch-zone {
            position: absolute;
            bottom: 20px;
        }
        .touch-zone.left {
            left: 15px;
        }
        .touch-zone.right {
            right: 15px;
        }
        .dpad {
            position: relative;
            width: 150px;
            height: 150px;
        }
        .dpad-btn {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255,255,255,0.4);
            border: 3px solid rgba(255,255,255,0.7);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #fff;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            touch-action: none;
        }
        .dpad-btn.active {
            background: rgba(255,255,255,0.7);
            transform-origin: center;
        }
        .dpad-btn.up { top: 0; left: 50%; transform: translateX(-50%); }
        .dpad-btn.up.active { transform: translateX(-50%) scale(0.95); }
        .dpad-btn.down { bottom: 0; left: 50%; transform: translateX(-50%); }
        .dpad-btn.down.active { transform: translateX(-50%) scale(0.95); }
        .dpad-btn.left { left: 0; top: 50%; transform: translateY(-50%); }
        .dpad-btn.left.active { transform: translateY(-50%) scale(0.95); }
        .dpad-btn.right { right: 0; top: 50%; transform: translateY(-50%); }
        .dpad-btn.right.active { transform: translateY(-50%) scale(0.95); }
        .action-btns {
            display: flex;
            flex-direction: column;
            gap: 12px;
            position: absolute;
            bottom: 20px;
        }
        .action-btns.p1 {
            left: 180px;
        }
        .action-btns.p2 {
            right: 180px;
        }
        .action-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: rgba(255,255,255,0.4);
            border: 3px solid rgba(255,255,255,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 15px;
            font-weight: bold;
            color: #fff;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            touch-action: none;
        }
        .action-btn.active {
            transform: scale(0.95);
        }
        .action-btn.attack {
            background: rgba(100,200,255,0.5);
            border-color: rgba(100,200,255,0.8);
        }
        .action-btn.smash {
            background: rgba(255,100,100,0.5);
            border-color: rgba(255,100,100,0.8);
        }
        .action-btn.jump {
            background: rgba(100,255,100,0.5);
            border-color: rgba(100,255,100,0.8);
        }
        .player-label {
            position: absolute;
            bottom: 185px;
            font-size: 16px;
            font-weight: bold;
        }
        .player-label.p1 { left: 70px; color: #4a9eff; }
        .player-label.p2 { right: 70px; color: #ff4a4a; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1400" height="500"></canvas>
        <div id="controls">
            <div class="player-controls">
                <h3 style="color: #4a9eff;">Player 1</h3>
                <div>Move: A/D | Jump: W | Crouch: S | Roll: S+A/D | Attack: F | Smash: G</div>
            </div>
            <div class="player-controls">
                <h3 style="color: #ff4a4a;">Player 2</h3>
                <div>Move: ←/→ | Jump: ↑ | Crouch: ↓ | Roll: ↓+←/→ | Attack: L | Smash: K</div>
            </div>
        </div>
    </div>

    <!-- Touch Controls for iPad/Mobile -->
    <div id="touchControls">
        <div class="player-label p1">P1</div>
        <div class="player-label p2">P2</div>

        <!-- Player 1 Controls (Left Side) -->
        <div class="touch-zone left">
            <div class="dpad">
                <div class="dpad-btn up" data-key="w">▲</div>
                <div class="dpad-btn down" data-key="s">▼</div>
                <div class="dpad-btn left" data-key="a">◀</div>
                <div class="dpad-btn right" data-key="d">▶</div>
            </div>
        </div>
        <div class="action-btns p1">
            <div class="action-btn jump" data-key="w">JUMP</div>
            <div class="action-btn attack" data-key="f">ATK</div>
            <div class="action-btn smash" data-key="g">SMASH</div>
        </div>

        <!-- Player 2 Controls (Right Side) -->
        <div class="touch-zone right">
            <div class="dpad">
                <div class="dpad-btn up" data-key="ArrowUp">▲</div>
                <div class="dpad-btn down" data-key="ArrowDown">▼</div>
                <div class="dpad-btn left" data-key="ArrowLeft">◀</div>
                <div class="dpad-btn right" data-key="ArrowRight">▶</div>
            </div>
        </div>
        <div class="action-btns p2">
            <div class="action-btn jump" data-key="ArrowUp">JUMP</div>
            <div class="action-btn attack" data-key="l">ATK</div>
            <div class="action-btn smash" data-key="k">SMASH</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Pre-render Minecraft background (render once, no flickering)
        const backgroundCanvas = document.createElement('canvas');
        backgroundCanvas.width = canvas.width;
        backgroundCanvas.height = canvas.height;
        const bgCtx = backgroundCanvas.getContext('2d');

        function renderBackground() {
            const blockSize = 20;

            // Sky gradient (top to bottom)
            for (let y = 0; y < canvas.height; y += blockSize) {
                for (let x = 0; x < canvas.width; x += blockSize) {
                    const skyProgress = y / canvas.height;
                    if (skyProgress < 0.6) {
                        // Sky blocks - light blue with slight variation
                        const shade = Math.floor(Math.random() * 20);
                        bgCtx.fillStyle = `rgb(${100 + shade}, ${180 + shade}, ${255 - shade})`;
                    } else if (skyProgress < 0.75) {
                        // Dirt blocks
                        const shade = Math.floor(Math.random() * 30);
                        bgCtx.fillStyle = `rgb(${139 - shade}, ${90 - shade}, ${43 - shade})`;
                    } else {
                        // Stone blocks at very bottom
                        const shade = Math.floor(Math.random() * 25);
                        bgCtx.fillStyle = `rgb(${100 + shade}, ${100 + shade}, ${100 + shade})`;
                    }
                    bgCtx.fillRect(x, y, blockSize, blockSize);

                    // Block outline for that pixelated look
                    bgCtx.strokeStyle = 'rgba(0,0,0,0.15)';
                    bgCtx.lineWidth = 1;
                    bgCtx.strokeRect(x, y, blockSize, blockSize);
                }
            }

            // Add some clouds (white blocks)
            const cloudPositions = [
                {x: 100, y: 40}, {x: 120, y: 40}, {x: 140, y: 40}, {x: 120, y: 20},
                {x: 400, y: 60}, {x: 420, y: 60}, {x: 440, y: 60}, {x: 460, y: 60}, {x: 420, y: 40}, {x: 440, y: 40},
                {x: 800, y: 30}, {x: 820, y: 30}, {x: 840, y: 30}, {x: 820, y: 10},
                {x: 1100, y: 50}, {x: 1120, y: 50}, {x: 1140, y: 50}, {x: 1160, y: 50}, {x: 1120, y: 30}, {x: 1140, y: 30}
            ];
            bgCtx.fillStyle = '#fff';
            cloudPositions.forEach(pos => {
                bgCtx.fillRect(pos.x, pos.y, blockSize, blockSize);
            });

            // Sun (yellow blocks in corner)
            bgCtx.fillStyle = '#FFD700';
            for (let sy = 0; sy < 3; sy++) {
                for (let sx = 0; sx < 3; sx++) {
                    bgCtx.fillRect(canvas.width - 100 + sx * blockSize, 20 + sy * blockSize, blockSize, blockSize);
                }
            }

            // Spikes at the bottom
            const spikeWidth = 20;
            const spikeHeight = 30;
            for (let x = 0; x < canvas.width; x += spikeWidth) {
                // Spike triangle
                bgCtx.fillStyle = '#444';
                bgCtx.beginPath();
                bgCtx.moveTo(x, canvas.height);
                bgCtx.lineTo(x + spikeWidth / 2, canvas.height - spikeHeight);
                bgCtx.lineTo(x + spikeWidth, canvas.height);
                bgCtx.closePath();
                bgCtx.fill();

                // Spike highlight
                bgCtx.strokeStyle = '#666';
                bgCtx.lineWidth = 2;
                bgCtx.beginPath();
                bgCtx.moveTo(x + spikeWidth / 2, canvas.height - spikeHeight);
                bgCtx.lineTo(x + spikeWidth, canvas.height);
                bgCtx.stroke();

                // Spike tip highlight
                bgCtx.fillStyle = '#888';
                bgCtx.beginPath();
                bgCtx.arc(x + spikeWidth / 2, canvas.height - spikeHeight + 3, 2, 0, Math.PI * 2);
                bgCtx.fill();
            }
        }
        renderBackground();

        // Game constants
        const GRAVITY = 0.6;
        const MOVE_SPEED = 5;
        const PLATFORM_HEIGHT = 80; // Vertical spacing between levels

        // Platforms array: {x, y, width}
        // 5 levels from bottom (y=420) to top (y=100), spaced 80px apart
        // Bigger platforms at bottom, smaller at top
        const platforms = [
            // Level 1 (bottom) - y=420 - LARGEST platforms
            { x: 50, y: 420, width: 300 },
            { x: 400, y: 420, width: 350 },
            { x: 800, y: 420, width: 300 },
            { x: 1150, y: 420, width: 200 },

            // Level 2 - y=340 - Large platforms
            { x: 100, y: 340, width: 220 },
            { x: 380, y: 340, width: 250 },
            { x: 700, y: 340, width: 220 },
            { x: 1000, y: 340, width: 200 },

            // Level 3 - y=260 - Medium platforms
            { x: 50, y: 260, width: 180 },
            { x: 300, y: 260, width: 180 },
            { x: 550, y: 260, width: 180 },
            { x: 800, y: 260, width: 180 },
            { x: 1050, y: 260, width: 180 },

            // Level 4 - y=180 - Small platforms
            { x: 150, y: 180, width: 140 },
            { x: 400, y: 180, width: 140 },
            { x: 650, y: 180, width: 140 },
            { x: 900, y: 180, width: 140 },
            { x: 1150, y: 180, width: 140 },

            // Level 5 (top) - y=100 - SMALLEST platforms
            { x: 250, y: 100, width: 100 },
            { x: 500, y: 100, width: 100 },
            { x: 750, y: 100, width: 100 },
            { x: 1000, y: 100, width: 100 },
        ];

        // Jump force calculated to reach just over one platform height (~85px)
        // Max height = v^2 / (2*g), so v = sqrt(2*g*h) = sqrt(2*0.6*85) ≈ 10.1
        const JUMP_FORCE = -10.5;
        const ATTACK_DAMAGE = 10;
        const SMASH_DAMAGE = 5;  // Low damage, high knockback
        const ATTACK_KNOCKBACK = 8;
        const SMASH_KNOCKBACK = 25; // Big knockback for ring outs
        const ROLL_SPEED = 5;  // Same as normal move speed
        const ROLL_DURATION = 20;
        const POWERUP_DURATION = 300; // 5 seconds at 60fps

        // Weapon types for powerups
        const WEAPONS = {
            sword: { name: 'Sword', color: '#cccccc', damage: 10, knockback: 8, range: 45, ranged: false },
            hammer: { name: 'Hammer', color: '#8B4513', damage: 8, knockback: 20, range: 35, ranged: false },
            spear: { name: 'Spear', color: '#FFD700', damage: 15, knockback: 5, range: 65, ranged: false },
            axe: { name: 'Axe', color: '#CD5C5C', damage: 20, knockback: 12, range: 40, ranged: false },
            bow: { name: 'Bow', color: '#90EE90', damage: 12, knockback: 6, range: 30, ranged: true },
        };

        // Projectiles array
        let projectiles = [];

        // Game state
        let gameState = 'playing'; // 'playing', 'gameover'
        let winner = null;
        let screenShake = 0;
        let powerups = [];
        let powerupSpawnTimer = 0;

        // Input handling
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            keys[e.key] = true;
            if (['w', 'a', 's', 'd', 'f', 'g', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'l', 'k'].includes(e.key) ||
                ['w', 'a', 's', 'd', 'f', 'g', 'l', 'k'].includes(e.key.toLowerCase())) {
                e.preventDefault();
            }
        });
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            keys[e.key] = false;
        });

        // Touch controls handling - track active touches per button
        const activeTouches = new Map(); // touchId -> button element

        function setKey(key, value) {
            keys[key] = value;
            // Also set lowercase version for letter keys
            if (key.length === 1) {
                keys[key.toLowerCase()] = value;
            }
        }

        function setupTouchControls() {
            const touchControls = document.getElementById('touchControls');
            if (!touchControls) return;

            // Global touch handlers on the touch controls container
            touchControls.addEventListener('touchstart', (e) => {
                e.preventDefault();
                for (const touch of e.changedTouches) {
                    const btn = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (btn && btn.dataset.key) {
                        activeTouches.set(touch.identifier, btn);
                        setKey(btn.dataset.key, true);
                        btn.classList.add('active');
                    }
                }
            }, { passive: false });

            touchControls.addEventListener('touchmove', (e) => {
                e.preventDefault();
                // Handle finger sliding between buttons
                for (const touch of e.changedTouches) {
                    const oldBtn = activeTouches.get(touch.identifier);
                    const newBtn = document.elementFromPoint(touch.clientX, touch.clientY);

                    if (oldBtn !== newBtn) {
                        // Release old button
                        if (oldBtn && oldBtn.dataset.key) {
                            setKey(oldBtn.dataset.key, false);
                            oldBtn.classList.remove('active');
                        }
                        // Press new button
                        if (newBtn && newBtn.dataset.key) {
                            activeTouches.set(touch.identifier, newBtn);
                            setKey(newBtn.dataset.key, true);
                            newBtn.classList.add('active');
                        } else {
                            activeTouches.delete(touch.identifier);
                        }
                    }
                }
            }, { passive: false });

            touchControls.addEventListener('touchend', (e) => {
                e.preventDefault();
                for (const touch of e.changedTouches) {
                    const btn = activeTouches.get(touch.identifier);
                    if (btn && btn.dataset.key) {
                        setKey(btn.dataset.key, false);
                        btn.classList.remove('active');
                    }
                    activeTouches.delete(touch.identifier);
                }
            }, { passive: false });

            touchControls.addEventListener('touchcancel', (e) => {
                for (const touch of e.changedTouches) {
                    const btn = activeTouches.get(touch.identifier);
                    if (btn && btn.dataset.key) {
                        setKey(btn.dataset.key, false);
                        btn.classList.remove('active');
                    }
                    activeTouches.delete(touch.identifier);
                }
            }, { passive: false });
        }

        // Initialize touch controls when DOM is ready
        setupTouchControls();

        // Touch to restart game (when game over)
        canvas.addEventListener('touchstart', (e) => {
            if (gameState === 'gameover') {
                e.preventDefault();
                resetGame();
            }
        }, { passive: false });

        // Also allow click to restart (for mouse on touch devices)
        canvas.addEventListener('click', (e) => {
            if (gameState === 'gameover') {
                resetGame();
            }
        });

        // PowerUp class - bouncing weapon pickups
        class PowerUp {
            constructor() {
                this.x = Math.random() * (canvas.width - 40) + 20;
                this.y = 50;
                this.vx = (Math.random() - 0.5) * 6;
                this.vy = (Math.random() + 0.5) * 3;
                this.size = 20;
                // Pick random weapon (not sword, that's default)
                const weaponTypes = ['hammer', 'spear', 'axe', 'bow'];
                this.weaponType = weaponTypes[Math.floor(Math.random() * weaponTypes.length)];
                this.weapon = WEAPONS[this.weaponType];
                this.bobOffset = Math.random() * Math.PI * 2;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                // Bounce off walls
                if (this.x <= this.size || this.x >= canvas.width - this.size) {
                    this.vx *= -1;
                    this.x = Math.max(this.size, Math.min(canvas.width - this.size, this.x));
                }

                // Bounce off top
                if (this.y <= this.size) {
                    this.vy *= -1;
                    this.y = this.size;
                }

                // Bounce off bottom (don't fall off screen)
                if (this.y >= canvas.height - this.size) {
                    this.vy *= -0.8;
                    this.y = canvas.height - this.size;
                    if (Math.abs(this.vy) < 1) this.vy = -3; // Keep bouncing
                }

                // Slow down slightly
                this.vx *= 0.999;
            }

            draw() {
                const bob = Math.sin(Date.now() / 200 + this.bobOffset) * 3;

                ctx.save();
                ctx.translate(this.x, this.y + bob);

                // Glowing circle background
                ctx.beginPath();
                ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fill();
                ctx.strokeStyle = this.weapon.color;
                ctx.lineWidth = 3;
                ctx.stroke();

                // Draw weapon icon
                ctx.strokeStyle = this.weapon.color;
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';

                if (this.weaponType === 'hammer') {
                    // Hammer icon
                    ctx.beginPath();
                    ctx.moveTo(0, 8);
                    ctx.lineTo(0, -4);
                    ctx.stroke();
                    ctx.fillStyle = this.weapon.color;
                    ctx.fillRect(-8, -10, 16, 8);
                } else if (this.weaponType === 'spear') {
                    // Spear icon
                    ctx.beginPath();
                    ctx.moveTo(0, 10);
                    ctx.lineTo(0, -8);
                    ctx.lineTo(-4, -4);
                    ctx.moveTo(0, -8);
                    ctx.lineTo(4, -4);
                    ctx.stroke();
                } else if (this.weaponType === 'axe') {
                    // Axe icon
                    ctx.beginPath();
                    ctx.moveTo(0, 10);
                    ctx.lineTo(0, -5);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(5, -5, 8, Math.PI * 0.5, Math.PI * 1.5);
                    ctx.fillStyle = this.weapon.color;
                    ctx.fill();
                } else if (this.weaponType === 'bow') {
                    // Bow icon
                    ctx.beginPath();
                    ctx.arc(-3, 0, 10, -Math.PI * 0.4, Math.PI * 0.4);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(-3, -6);
                    ctx.lineTo(-3, 6);
                    ctx.stroke();
                    // Arrow
                    ctx.beginPath();
                    ctx.moveTo(-3, 0);
                    ctx.lineTo(10, 0);
                    ctx.lineTo(7, -3);
                    ctx.moveTo(10, 0);
                    ctx.lineTo(7, 3);
                    ctx.stroke();
                }

                ctx.restore();
            }

            checkCollision(player) {
                const dx = this.x - (player.x + player.width / 2);
                const dy = this.y - (player.y - player.height / 2);
                const dist = Math.sqrt(dx * dx + dy * dy);
                return dist < this.size + 25;
            }
        }

        // Projectile class for ranged weapons
        class Projectile {
            constructor(x, y, direction, owner, weapon) {
                this.x = x;
                this.y = y;
                this.vx = direction * 15;
                this.vy = 0;
                this.owner = owner;
                this.weapon = weapon;
                this.life = 120; // 2 seconds
            }

            update() {
                this.x += this.vx;
                this.vy += 0.1; // Slight gravity
                this.y += this.vy;
                this.life--;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(Math.atan2(this.vy, this.vx));

                // Arrow
                ctx.strokeStyle = this.weapon.color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(-15, 0);
                ctx.lineTo(10, 0);
                ctx.lineTo(6, -4);
                ctx.moveTo(10, 0);
                ctx.lineTo(6, 4);
                ctx.stroke();

                // Fletching
                ctx.beginPath();
                ctx.moveTo(-15, 0);
                ctx.lineTo(-12, -4);
                ctx.moveTo(-15, 0);
                ctx.lineTo(-12, 4);
                ctx.stroke();

                ctx.restore();
            }

            checkHit(player) {
                if (player === this.owner) return false;
                return this.x > player.x - 10 &&
                       this.x < player.x + player.width + 10 &&
                       this.y > player.y - player.height - 10 &&
                       this.y < player.y + 10;
            }
        }

        class Player {
            constructor(x, y, color, controls, facingRight) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.width = 30;
                this.height = 60;
                this.color = color;
                this.controls = controls;
                this.facingRight = facingRight;
                this.health = 100;
                this.maxHealth = 100;
                this.isGrounded = false;
                this.isAttacking = false;
                this.isSmashing = false;
                this.attackTimer = 0;
                this.smashTimer = 0;
                this.attackCooldown = 0;
                this.smashCooldown = 0;
                this.invincible = 0;
                this.hitFlash = 0;
                this.swordAngle = 0;
                this.targetSwordAngle = 0;
                this.isRolling = false;
                this.rollTimer = 0;
                this.rollCooldown = 0;
                this.rollDirection = 1;
                this.isCrouching = false;
                this.weapon = WEAPONS.sword;
                this.weaponTimer = 0;
            }

            update(other) {
                // Rolling state
                if (this.isRolling) {
                    this.vx = this.rollDirection * ROLL_SPEED;
                    this.rollTimer--;
                    if (this.rollTimer <= 0) {
                        this.isRolling = false;
                    }
                    // Invincible during roll
                    this.invincible = 5;
                } else {
                    // Handle input (only when not rolling)
                    if (keys[this.controls.left]) {
                        this.vx = -MOVE_SPEED;
                        this.facingRight = false;
                    } else if (keys[this.controls.right]) {
                        this.vx = MOVE_SPEED;
                        this.facingRight = true;
                    } else {
                        this.vx *= 0.8;
                    }

                    // Roll - press down + direction
                    if (keys[this.controls.down] && this.rollCooldown <= 0 && this.isGrounded) {
                        if (keys[this.controls.left]) {
                            this.isRolling = true;
                            this.rollTimer = ROLL_DURATION;
                            this.rollCooldown = 40;
                            this.rollDirection = -1;
                            this.facingRight = false;
                            this.isCrouching = false;
                        } else if (keys[this.controls.right]) {
                            this.isRolling = true;
                            this.rollTimer = ROLL_DURATION;
                            this.rollCooldown = 40;
                            this.rollDirection = 1;
                            this.facingRight = true;
                            this.isCrouching = false;
                        } else {
                            // Just crouch (down without direction)
                            this.isCrouching = true;
                        }
                    } else {
                        this.isCrouching = false;
                    }

                    // Jump
                    if (keys[this.controls.jump] && this.isGrounded) {
                        this.vy = JUMP_FORCE;
                        this.isGrounded = false;
                    }
                }

                // Attack (not while rolling)
                if (keys[this.controls.attack] && this.attackCooldown <= 0 && !this.isAttacking && !this.isSmashing && !this.isRolling) {
                    this.isAttacking = true;
                    this.attackTimer = 15;
                    this.attackCooldown = 25;

                    // Ranged weapon shoots projectile
                    if (this.weapon.ranged) {
                        const dir = this.facingRight ? 1 : -1;
                        const crouchOffset = this.isCrouching ? 20 : 0;
                        projectiles.push(new Projectile(
                            this.x + this.width / 2 + dir * 20,
                            this.y - 30 + crouchOffset,
                            dir,
                            this,
                            this.weapon
                        ));
                    }
                }

                // Smash (not while rolling)
                if (keys[this.controls.smash] && this.smashCooldown <= 0 && !this.isAttacking && !this.isSmashing && !this.isRolling) {
                    this.isSmashing = true;
                    this.smashTimer = 30;
                    this.smashCooldown = 50;
                }

                // Apply gravity
                this.vy += GRAVITY;
                this.y += this.vy;
                this.x += this.vx;

                // Platform collision
                this.isGrounded = false;

                // Check all platforms
                for (const plat of platforms) {
                    if (this.x + this.width > plat.x && this.x < plat.x + plat.width) {
                        // Only land if falling down onto platform
                        if (this.vy >= 0 && this.y >= plat.y - 15 && this.y <= plat.y + 5) {
                            this.y = plat.y;
                            this.vy = 0;
                            this.isGrounded = true;
                            break;
                        }
                    }
                }

                // Player-to-player collision
                const overlapX = (this.x + this.width) - other.x;
                const overlapX2 = (other.x + other.width) - this.x;
                if (overlapX > 0 && overlapX2 > 0 &&
                    this.y > other.y - other.height && this.y - this.height < other.y) {
                    // Check if running into a crouching player - hop over them!
                    if (other.isCrouching && Math.abs(this.vx) > 3 && this.isGrounded) {
                        this.vy = -6; // Small hop (not enough to reach next level)
                        this.vx *= 2; // Boost momentum to clear over them
                        this.isGrounded = false;
                    } else if (!this.isCrouching) {
                        // Normal push apart (don't push crouching player)
                        if (overlapX < overlapX2) {
                            this.x -= overlapX / 2 + 1;
                        } else {
                            this.x += overlapX2 / 2 + 1;
                        }
                    }
                }

                // Screen bounds (can fall off sides too)
                if (this.x < -50) this.x = -50;
                if (this.x > canvas.width + 20) this.x = canvas.width + 20;

                // Spike pit at bottom - deals damage over time
                const spikeY = canvas.height - 30;
                if (this.y > spikeY) {
                    // Take damage (0.5 per frame = 30 per second)
                    this.health -= 0.5;
                    this.hitFlash = 5;
                    screenShake = 2;
                    // Can stand on spikes but still jump out
                    if (this.y > canvas.height) {
                        this.y = canvas.height;
                        this.isGrounded = true;
                        if (this.vy > 0) this.vy = 0;
                    }
                }

                // Update timers
                if (this.attackTimer > 0) this.attackTimer--;
                if (this.smashTimer > 0) this.smashTimer--;
                if (this.attackCooldown > 0) this.attackCooldown--;
                if (this.smashCooldown > 0) this.smashCooldown--;
                if (this.rollCooldown > 0) this.rollCooldown--;
                if (this.invincible > 0) this.invincible--;
                if (this.hitFlash > 0) this.hitFlash--;

                if (this.attackTimer <= 0) this.isAttacking = false;
                if (this.smashTimer <= 0) this.isSmashing = false;

                // Weapon timer - revert to sword when expired
                if (this.weaponTimer > 0) {
                    this.weaponTimer--;
                    if (this.weaponTimer <= 0) {
                        this.weapon = WEAPONS.sword;
                    }
                }

                // Sword animation - angles based on facing direction
                if (this.isAttacking) {
                    // Quick swing: sword goes from up to forward
                    this.targetSwordAngle = this.facingRight ? 0 : Math.PI;
                } else if (this.isSmashing) {
                    // Heavy overhead swing
                    const progress = 1 - (this.smashTimer / 30);
                    if (this.facingRight) {
                        this.targetSwordAngle = -Math.PI * 0.8 + progress * Math.PI * 1.3;
                    } else {
                        this.targetSwordAngle = Math.PI * 0.8 - progress * Math.PI * 1.3;
                    }
                } else {
                    // Idle: sword held up and ready
                    this.targetSwordAngle = this.facingRight ? -Math.PI / 4 : Math.PI + Math.PI / 4;
                }
                this.swordAngle += (this.targetSwordAngle - this.swordAngle) * 0.3;

                // Hit detection
                if ((this.isAttacking && this.attackTimer > 5) || (this.isSmashing && this.smashTimer > 10 && this.smashTimer < 25)) {
                    const swordLine = this.getSwordLine();
                    if (this.checkHit(other, swordLine)) {
                        if (other.invincible <= 0) {
                            // Use weapon stats for damage, smash multiplies knockback
                            const damage = this.isSmashing ? SMASH_DAMAGE : this.weapon.damage;
                            const knockback = this.isSmashing ? SMASH_KNOCKBACK : this.weapon.knockback;
                            other.health -= damage;
                            other.invincible = 30;
                            other.hitFlash = 10;
                            other.vx = this.facingRight ? knockback : -knockback;
                            other.vy = -knockback / 6;
                            screenShake = this.isSmashing ? 15 : 8;
                        }
                    }
                }
            }

            getSwordLine() {
                const centerX = this.x + this.width / 2;
                const feetY = this.y;
                const dir = this.facingRight ? 1 : -1;
                const crouchOffset = this.isCrouching ? 15 : 0;
                const headY = feetY - 55 + crouchOffset;
                const headRadius = 10;
                const shoulderY = headY + headRadius;
                const handX = centerX + dir * 22;
                const handY = shoulderY + 15 + crouchOffset;
                const weaponLength = this.weapon.range;
                return {
                    x1: handX,
                    y1: handY,
                    x2: handX + Math.cos(this.swordAngle) * weaponLength,
                    y2: handY + Math.sin(this.swordAngle) * weaponLength
                };
            }

            getSwordTip() {
                const line = this.getSwordLine();
                return { x: line.x2, y: line.y2 };
            }

            checkHit(other, swordLine) {
                // Check if sword blade (line) intersects with opponent hitbox
                const boxLeft = other.x - 10;
                const boxRight = other.x + other.width + 10;
                const boxTop = other.y - other.height - 10;
                const boxBottom = other.y + 10;

                // Check multiple points along the blade
                for (let t = 0; t <= 1; t += 0.1) {
                    const px = swordLine.x1 + (swordLine.x2 - swordLine.x1) * t;
                    const py = swordLine.y1 + (swordLine.y2 - swordLine.y1) * t;
                    if (px > boxLeft && px < boxRight && py > boxTop && py < boxBottom) {
                        return true;
                    }
                }
                return false;
            }

            draw() {
                ctx.save();

                const centerX = this.x + this.width / 2;
                const feetY = this.y;
                const dir = this.facingRight ? 1 : -1;

                // Victory dab pose (stick figure style)
                if (gameState === 'gameover' && this.health > 0) {
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';

                    const dabHeadX = centerX;
                    const dabHeadY = feetY - 50;
                    const dabHeadRadius = 10;

                    // Head
                    ctx.beginPath();
                    ctx.arc(dabHeadX, dabHeadY, dabHeadRadius, 0, Math.PI * 2);
                    ctx.stroke();

                    // Body
                    const dabShoulderY = dabHeadY + dabHeadRadius;
                    const dabHipY = dabShoulderY + 20;
                    ctx.beginPath();
                    ctx.moveTo(dabHeadX, dabShoulderY);
                    ctx.lineTo(dabHeadX, dabHipY);
                    ctx.stroke();

                    // Legs (spread stance)
                    const dabFootY = dabHipY + 18;
                    ctx.beginPath();
                    ctx.moveTo(dabHeadX, dabHipY);
                    ctx.lineTo(dabHeadX - 10, dabFootY);
                    ctx.moveTo(dabHeadX, dabHipY);
                    ctx.lineTo(dabHeadX + 10, dabFootY);
                    ctx.stroke();

                    // Dab arm (across face)
                    ctx.beginPath();
                    ctx.moveTo(dabHeadX, dabShoulderY);
                    ctx.lineTo(dabHeadX + 20, dabHeadY - 5);
                    ctx.stroke();

                    // Extended arm (pointing out diagonally)
                    ctx.beginPath();
                    ctx.moveTo(dabHeadX, dabShoulderY);
                    ctx.lineTo(dabHeadX - 30, dabShoulderY - 15);
                    ctx.stroke();

                    ctx.restore();
                    return;
                }

                // Flash when hit
                if (this.hitFlash > 0 && this.hitFlash % 2 === 0) {
                    ctx.globalAlpha = 0.5;
                }

                // Invincibility flicker
                if (this.invincible > 0 && this.invincible % 4 < 2) {
                    ctx.globalAlpha = 0.7;
                }

                // Roll animation (stick figure tumbling)
                if (this.isRolling) {
                    const rollProgress = (ROLL_DURATION - this.rollTimer) / ROLL_DURATION;
                    const rotation = rollProgress * Math.PI * 4 * this.rollDirection;

                    ctx.translate(centerX, feetY - 25);
                    ctx.rotate(rotation);

                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';

                    // Curled up stick figure
                    // Head
                    ctx.beginPath();
                    ctx.arc(8, -8, 8, 0, Math.PI * 2);
                    ctx.stroke();

                    // Curved body
                    ctx.beginPath();
                    ctx.arc(0, 0, 12, -0.5, Math.PI + 0.5);
                    ctx.stroke();

                    // Tucked limbs
                    ctx.beginPath();
                    ctx.moveTo(-8, 8);
                    ctx.lineTo(-5, 15);
                    ctx.moveTo(8, 8);
                    ctx.lineTo(5, 15);
                    ctx.stroke();

                    ctx.restore();
                    return;
                }

                // Draw classic stick figure
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';

                // Crouch makes character shorter
                const crouchOffset = this.isCrouching ? 15 : 0;

                // Head position
                const headX = centerX;
                const headY = feetY - 55 + crouchOffset;
                const headRadius = 10;

                // Head (circle outline)
                ctx.beginPath();
                ctx.arc(headX, headY, headRadius, 0, Math.PI * 2);
                ctx.stroke();

                // Body (torso line)
                const shoulderY = headY + headRadius;
                const hipY = shoulderY + 20;
                ctx.beginPath();
                ctx.moveTo(headX, shoulderY);
                ctx.lineTo(headX, hipY);
                ctx.stroke();

                // Legs
                const walkOffset = Math.sin(Date.now() / 100) * (Math.abs(this.vx) > 0.5 ? 5 : 0);
                const footY = hipY + 18;

                if (this.isCrouching) {
                    // Bent legs for crouch
                    ctx.beginPath();
                    ctx.moveTo(headX, hipY);
                    ctx.lineTo(headX - 12, footY);
                    ctx.moveTo(headX, hipY);
                    ctx.lineTo(headX + 12, footY);
                    ctx.stroke();
                } else {
                    ctx.beginPath();
                    ctx.moveTo(headX, hipY);
                    ctx.lineTo(headX - 8 + walkOffset, footY);
                    ctx.moveTo(headX, hipY);
                    ctx.lineTo(headX + 8 - walkOffset, footY);
                    ctx.stroke();
                }

                // Arms
                const handX = headX + dir * 22;
                const handY = shoulderY + 15 + crouchOffset;

                // Back arm
                ctx.beginPath();
                ctx.moveTo(headX, shoulderY);
                ctx.lineTo(headX - dir * 15, shoulderY + 12);
                ctx.stroke();

                // Sword arm
                ctx.beginPath();
                ctx.moveTo(headX, shoulderY);
                ctx.lineTo(handX, handY);
                ctx.stroke();

                // Weapon
                const weaponLength = this.weapon.range;
                const weaponEndX = handX + Math.cos(this.swordAngle) * weaponLength;
                const weaponEndY = handY + Math.sin(this.swordAngle) * weaponLength;

                // Weapon glow when attacking
                if (this.isAttacking || this.isSmashing) {
                    ctx.strokeStyle = this.isSmashing ? '#ffaa00' : '#ffffff';
                    ctx.lineWidth = 6;
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(handX, handY);
                    ctx.lineTo(weaponEndX, weaponEndY);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }

                // Weapon blade/head
                ctx.strokeStyle = this.weapon.color;
                ctx.lineWidth = this.weapon.name === 'Hammer' ? 6 : 3;
                ctx.beginPath();
                ctx.moveTo(handX, handY);
                ctx.lineTo(weaponEndX, weaponEndY);
                ctx.stroke();

                // Weapon head for hammer/axe
                if (this.weapon.name === 'Hammer') {
                    ctx.fillStyle = this.weapon.color;
                    ctx.save();
                    ctx.translate(weaponEndX, weaponEndY);
                    ctx.rotate(this.swordAngle);
                    ctx.fillRect(-12, -5, 12, 10);
                    ctx.restore();
                } else if (this.weapon.name === 'Axe') {
                    ctx.fillStyle = this.weapon.color;
                    ctx.save();
                    ctx.translate(weaponEndX, weaponEndY);
                    ctx.rotate(this.swordAngle + Math.PI / 2);
                    ctx.beginPath();
                    ctx.arc(0, 0, 10, 0, Math.PI);
                    ctx.fill();
                    ctx.restore();
                }

                // Handle
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(handX, handY);
                ctx.lineTo(handX + Math.cos(this.swordAngle) * 8, handY + Math.sin(this.swordAngle) * 8);
                ctx.stroke();

                // Weapon timer indicator
                if (this.weaponTimer > 0) {
                    ctx.fillStyle = this.weapon.color;
                    ctx.globalAlpha = 0.7;
                    ctx.fillRect(this.x - 5, this.y - this.height - 15, (this.weaponTimer / POWERUP_DURATION) * 40, 5);
                    ctx.globalAlpha = 1;
                }

                ctx.restore();
            }
        }

        // Create players (spawn on bottom level platforms)
        const player1 = new Player(450, platforms[1].y, '#4a9eff', {
            left: 'a',
            right: 'd',
            jump: 'w',
            down: 's',
            attack: 'f',
            smash: 'g'
        }, true);

        const player2 = new Player(800, platforms[2].y, '#ff4a4a', {
            left: 'ArrowLeft',
            right: 'ArrowRight',
            jump: 'ArrowUp',
            down: 'ArrowDown',
            attack: 'l',
            smash: 'k'
        }, false);

        function drawHealthBar(player, x, label) {
            const barWidth = 200;
            const barHeight = 20;
            const healthPercent = Math.max(0, player.health / player.maxHealth);

            // Background
            ctx.fillStyle = '#333';
            ctx.fillRect(x, 20, barWidth, barHeight);

            // Health
            ctx.fillStyle = player.color;
            ctx.fillRect(x, 20, barWidth * healthPercent, barHeight);

            // Border
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, 20, barWidth, barHeight);

            // Label
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px Arial';
            ctx.fillText(label, x, 55);
            ctx.fillText(`${Math.max(0, Math.ceil(player.health))}%`, x + barWidth - 30, 55);
        }

        function drawPlatforms() {
            const blockSize = 20;
            for (const plat of platforms) {
                const numBlocks = Math.floor(plat.width / blockSize);

                for (let i = 0; i < numBlocks; i++) {
                    const blockX = plat.x + i * blockSize;

                    // Top layer - grass block
                    const grassShade = Math.floor(Math.random() * 30);
                    ctx.fillStyle = `rgb(${80 + grassShade}, ${180 + grassShade}, ${80 + grassShade})`;
                    ctx.fillRect(blockX, plat.y, blockSize, blockSize / 2);

                    // Bottom layer - dirt block
                    const dirtShade = Math.floor(Math.random() * 20);
                    ctx.fillStyle = `rgb(${139 - dirtShade}, ${90 - dirtShade}, ${43 - dirtShade})`;
                    ctx.fillRect(blockX, plat.y + blockSize / 2, blockSize, blockSize / 2 + 5);

                    // Block outline
                    ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(blockX, plat.y, blockSize, blockSize / 2);
                    ctx.strokeRect(blockX, plat.y + blockSize / 2, blockSize, blockSize / 2 + 5);
                }
            }
        }

        // Detect touch device
        const isTouchDevice = window.matchMedia('(pointer: coarse)').matches;

        function drawGameOver() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = winner === 1 ? '#4a9eff' : '#ff4a4a';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`Player ${winner} Wins!`, canvas.width / 2, canvas.height / 2 - 20);

            ctx.fillStyle = '#fff';
            ctx.font = '24px Arial';
            const restartText = isTouchDevice ? 'Tap screen to restart' : 'Press SPACE to restart';
            ctx.fillText(restartText, canvas.width / 2, canvas.height / 2 + 30);
            ctx.textAlign = 'left';
        }

        function resetGame() {
            player1.x = 450;
            player1.y = platforms[1].y;
            player1.vx = 0;
            player1.vy = 0;
            player1.health = 100;
            player1.facingRight = true;
            player1.isAttacking = false;
            player1.isSmashing = false;
            player1.attackTimer = 0;
            player1.smashTimer = 0;
            player1.attackCooldown = 0;
            player1.smashCooldown = 0;
            player1.invincible = 0;
            player1.weapon = WEAPONS.sword;
            player1.weaponTimer = 0;

            player2.x = 800;
            player2.y = platforms[2].y;
            player2.vx = 0;
            player2.vy = 0;
            player2.health = 100;
            player2.facingRight = false;
            player2.isAttacking = false;
            player2.isSmashing = false;
            player2.attackTimer = 0;
            player2.smashTimer = 0;
            player2.attackCooldown = 0;
            player2.smashCooldown = 0;
            player2.invincible = 0;
            player2.weapon = WEAPONS.sword;
            player2.weaponTimer = 0;

            // Clear powerups and projectiles
            powerups = [];
            projectiles = [];
            powerupSpawnTimer = 0;

            gameState = 'playing';
            winner = null;
        }

        function gameLoop() {
            // Screen shake offset
            let shakeX = 0, shakeY = 0;
            if (screenShake > 0) {
                shakeX = (Math.random() - 0.5) * screenShake;
                shakeY = (Math.random() - 0.5) * screenShake;
                screenShake *= 0.9;
                if (screenShake < 0.5) screenShake = 0;
            }

            ctx.save();
            ctx.translate(shakeX, shakeY);

            // Draw cached background
            ctx.drawImage(backgroundCanvas, 0, 0);

            if (gameState === 'playing') {
                // Update players
                player1.update(player2);
                player2.update(player1);

                // Spawn powerups periodically
                powerupSpawnTimer++;
                if (powerupSpawnTimer >= 300 && powerups.length < 3) { // Every 5 seconds, max 3
                    powerups.push(new PowerUp());
                    powerupSpawnTimer = 0;
                }

                // Update powerups
                for (let i = powerups.length - 1; i >= 0; i--) {
                    powerups[i].update();

                    // Check collection by players
                    if (powerups[i].checkCollision(player1)) {
                        player1.weapon = powerups[i].weapon;
                        player1.weaponTimer = POWERUP_DURATION;
                        powerups.splice(i, 1);
                    } else if (powerups[i].checkCollision(player2)) {
                        player2.weapon = powerups[i].weapon;
                        player2.weaponTimer = POWERUP_DURATION;
                        powerups.splice(i, 1);
                    }
                }

                // Update projectiles
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    projectiles[i].update();

                    // Check if expired or off screen
                    if (projectiles[i].life <= 0 || projectiles[i].x < -50 || projectiles[i].x > canvas.width + 50 || projectiles[i].y > canvas.height + 50) {
                        projectiles.splice(i, 1);
                        continue;
                    }

                    // Check platform collision
                    const proj = projectiles[i];
                    let hitPlatform = false;
                    for (const plat of platforms) {
                        if (proj.x > plat.x && proj.x < plat.x + plat.width &&
                            proj.y > plat.y && proj.y < plat.y + 20) {
                            hitPlatform = true;
                            break;
                        }
                    }
                    if (hitPlatform) {
                        projectiles.splice(i, 1);
                        continue;
                    }

                    // Check hits on players
                    if (proj.checkHit(player1) && player1.invincible <= 0) {
                        player1.health -= proj.weapon.damage;
                        player1.invincible = 30;
                        player1.hitFlash = 10;
                        player1.vx = proj.vx > 0 ? proj.weapon.knockback : -proj.weapon.knockback;
                        player1.vy = -4;
                        screenShake = 6;
                        projectiles.splice(i, 1);
                    } else if (proj.checkHit(player2) && player2.invincible <= 0) {
                        player2.health -= proj.weapon.damage;
                        player2.invincible = 30;
                        player2.hitFlash = 10;
                        player2.vx = proj.vx > 0 ? proj.weapon.knockback : -proj.weapon.knockback;
                        player2.vy = -4;
                        screenShake = 6;
                        projectiles.splice(i, 1);
                    }
                }

                // Check for winner
                if (player1.health <= 0) {
                    gameState = 'gameover';
                    winner = 2;
                } else if (player2.health <= 0) {
                    gameState = 'gameover';
                    winner = 1;
                }
            }

            // Draw
            drawPlatforms();

            // Draw powerups
            for (const powerup of powerups) {
                powerup.draw();
            }

            // Draw projectiles
            for (const proj of projectiles) {
                proj.draw();
            }

            player1.draw();
            player2.draw();
            drawHealthBar(player1, 20, 'Player 1');
            drawHealthBar(player2, canvas.width - 220, 'Player 2');

            ctx.restore();

            if (gameState === 'gameover') {
                drawGameOver();
                if (keys[' ']) {
                    resetGame();
                }
            }

            requestAnimationFrame(gameLoop);
        }

        // Start the game
        gameLoop();
    </script>
</body>
</html>
